
$color-primary: #55c57a;
$color-primary-light: #7ed56f;
$color-primary-dark: #28b485;

$color-grey-dark: #777; 
$color-white: #fff;
/* there are two forms of animation, the easy one is transition and the other one is the keyframe properties */

/* basic reset */
*::after, /* this enables the after and beofre element to also get the declared behaviour and not just the real element alone */
*::before {
  margin: 0;
  padding: 0;
  box-sizing: inherit; /* every element should inherit the box sizing */
}

/* rem is calculated in realtion to the root font size */
html {
  font-size: 62.5%; /* root font size */
}


/* all of these will be inherited */
body {
  font-family: "Lato", sans-serif;
  font-weight: 400;
  /* font-size: 16px; */
  line-height: 1.7;
  color: $color-grey-dark;
  padding: 3rem;
  box-sizing: border-box;
}
/*
note: to specify graident we always use the background image property
we want the gradient to be on top so it has to be the first attribute that we specify b4 the image
*/
.header {
  height: 95vh; /*means height of the element should be 95% of the view pirt height*/
  background-image: linear-gradient(
    to right bottom,
   rgba($color-primary-light, 0.8), 
   rgba($color-primary-dark, 0.8)), 
   url(../img/hero.jpg);
  background-size: cover; /* always tries to fit the image inside the element viewport or box  */
  background-position: top; /* it ensures d top of d image stays at d top of d container&remain d same no matter how d view port changes */
  clip-path: polygon(0 0, 100% 0, 100% 75vh, 0 100%);
  position: relative;
}

.header__logo-box {
  position: absolute;
  top: 4rem; /* the direction will be relative to the parent element that has a position set to relative..in this case.. */
  left: 4rem; /*..d parent element is d header element wit d header class, so dis is d reference 4rm which top,left starts to count*/
}

.header__logo {
  height: 3.5rem; /*set d height&d width will be figured out by d browser or set d width&d height will b firgured out by d browser */
}

.header__text-box {
  position: absolute;
  top: 40%;
  left: 50%;
  transform: translate(-50%, -50%);/* this 50% are now no longer in relation to the parent element but of(multiply) the element itself */
  text-align: center;
}

.heading-primary {
  color: $color-white;
  text-transform: uppercase;
  backface-visibility: hidden; /*  just a hack: prevents the animation from shaking at the end
  the backface visibility actually determines if the back part of an element when we transform it is visible or
  hidden for the user.  */
  margin-bottom: 6rem;
}

.heading-primary--main {
 display: block; /* block level element occupies the entire width that they have available and they creates line breaks after and before them */
 font-size: 6rem;
 font-weight: 400;
 letter-spacing: 3.5rem;
 animation-name: moveInLeft;
 animation-duration: 1s;
 animation-timing-function: ease-out; /*read doc: https://developer.mozilla.org/en-US/docs/Web/CSS/animation-timing-function */
 /* 
 animation-delay: 3s; 
 animation-iteration-count: 3;
 */
}

.heading-primary--sub {
  display: block;
  font-size: 2rem;
  font-weight: 700;
  letter-spacing: 1.75rem;
  animation: moveInRight 1s ease-out;
}

@keyframes moveInLeft {
  0% {
    opacity: 0;
    transform: translateX(-10rem)
  }

  80% {
    transform: translateX(1rem);
  }

  100% {
    opacity: 1;
    transform: translate(0)
  }
}

@keyframes moveInRight {
  0% {
    opacity: 0;
    transform: translateX(10rem)
  }

  80% {
    transform: translateX(-1rem);
  }

  100% {
    opacity: 1;
    transform: translate(0)
  }
}

@keyframes moveInBottom {
  0% {
    opacity: 0;
    transform: translateY(3rem)
  }

  100% {
    opacity: 1;
    transform: translate(0)
  }
}

/* to center this button, it is an inline block so it is treated as if it is a text so set the text align property of 
the parent center, the parent in this case is the class text-box */
/* inline-block will allow the box model to work on an inline element as if they were block level element */    
.btn:link, 
.btn:visited {
  text-transform: uppercase;
  text-decoration: none;
  padding: 1.5rem 4rem;
  display: inline-block; /* always do this if u want 2 give some padding, or height or width 2 some element(I think inline element) */
  border-radius: 10rem;
  transition: all .2s; /* the transition property is on the initial state i.e .btn:link */
  position: relative;
  font-size: 1.6rem;
}

.btn:hover {
  transform: translateY(-3px);
  box-shadow: 0 1rem 2rem rgba(0, 0, 0, 0.2);
}

.btn:active {
  transform: translateY(-1px);
  box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.2);
}

.btn--white {
  background-color: $color-white;
  color: $color-grey-dark;
}

/* adds a virtual element after the element that we are selecting */
.btn::after {
  content: '';
  display: inline-block; /* content and display property are required for it to work */
  height: 100%;  /* pseudo element is a child of it element e.g the pseudo element is a child of .btn so the height or  */
  width: 100%;  /* is relative to the parent, i.e the width for instance is 100% of .btn */
  border-radius: 10rem;
  position: absolute; /* puts the pseudo element on top of our actual button */
  top: 0;
  left: 0;
  z-index: -1; /* specifies the position of an element if they are on top one another */
  transition: all .4s;
}

.btn--white::after {
  background-color: #fff;
}

.btn:hover::after {
  transform: scaleX(1.4) scaleY(1.6);
  opacity: 0
}

.btn--animated {
  animation: moveInBottom .5s ease-out .75s;
  animation-fill-mode: backwards /* applies the style of the 0% before the animation starts */
}

